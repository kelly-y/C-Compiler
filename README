程式執行要素：
antlr-3.5.2-complete.jar, 
myCompiler.g,
myCompiler_test.java,
sample1.c,
sample2.c,
sample3.c, 
makefile

本次作業為使輸出完整及方便將輸出存為檔案，
執行 make 相關指令時預設不會顯示指令，
若需顯示指令，
將 makefile 中的所有"@"符號刪除即可。

將輸出存成檔案方式：
於執行程式指令加入"> xx.ll"，
例如：$make exe1 > xx.ll，
(執行ll檔方式為輸入 $lli xx.ll)。

編譯程式：
輸入：$make -> 可產生myCompilerLexer.java, myCompilerParser.java, myCompiler.tokens, myCompiler_test.class
p.s. 指令：java -cp antlr-3.5.2-complete.jar org.antlr.Tool myCompiler.g
		   javac -cp ./antlr-3.5.2-complete.jar myCompiler_test.java

執行程式：
輸入：$make exe1 -> 可編譯後輸出 sample1.c 的 llvm code
p.s. 指令：java -cp antlr-3.5.2-complete.jar:. myCompiler_test sample1.c
輸入：$make exe2 -> 可編譯後輸出 sample2.c 的 llvm code
p.s. 指令：java -cp antlr-3.5.2-complete.jar:. myCompiler_test sample2.c
輸入：$make exe3 -> 可編譯後輸出 sample3.c 的 llvm code
p.s. 指令：java -cp antlr-3.5.2-complete.jar:. myCompiler_test sample3.c

清空make產生的檔案：
輸入：$make clean -> 刪除所有class檔, tokens檔, myCompilerParser.java及myCompilerLexer.java
p.s. 指令：rm -f *.tokens *.class myCompilerLexer.java myCompilerParser.java

備註：
1. 即使跳過make步驟，輸入make exe1, 2, 3也可以順利編譯執行。
2. myCompiler.g內加入(ELSE) => if_then_loop_statements語法，告知antlr優先match後方else規則。
3. 一旦發現有Type Error, Undeclared Variable, Redeclared Variable，程式會直接中止執行。
4. $make exe1 後方加入 "> xx.ll" 可將輸出存入檔案中。
5. $make clean 不會刪除ll檔，若要刪除需再多輸入 $rm -f xx.ll。
6. 資料夾內原本就包含 sample1.ll, sample2.ll, sample3.ll，為sample1.c, sample2.c, sample3.c的llvm code，
   檔案中的內容和輸入 $make exe1, $make exe2, $make exe3 指令所輸出的內容一致。